ELF 바이너리 해부도: 섹션 헤더, 심볼, 그리고 본문의 시각적 분석

1. ELF 파일의 전체 지도 (The Big Picture)

ELF 파일을 이해하기 어려운 이유는 파일 내부에서 **"주소(Address)"**와 **"오프셋(Offset)"**이 혼용되고, 서로 다른 테이블들이 복잡하게 얽혀 있기 때문입니다.

먼저, ELF 파일을 하나의 거대한 **책(Book)**으로 상상해 봅시다.

```text
+-------------------------------------------------------------------------+
| 1 ELF Header (책의 표지)                                                |
| - 이 책은 64비트용이다.                                                 |
| - 목차(섹션 헤더 테이블)는 1200페이지(오프셋)에 있다.                   |
| - 목차 항목 하나는 64바이트다.                                          |
+-------------------------------------------------------------------------+
| ... (본문 내용: 코드, 데이터 등)...                                     |
|                                                                         |
| [.text 섹션 본문 ]   (실제 기계어 코드)                                  |
| [.data 섹션 본문 ]   (전역 변수 값)                                      |
| [.rodata 섹션 본문 ] ("Hello World" 같은 문자열 상수)                    |
| [.strtab 섹션 본문 ] (심볼 이름들이 모여있는 문자열 덩어리)              |
|                                                                         |
+-------------------------------------------------------------------------+
| 2 Section Header Table (상세 목차)                                       |
| - 항목 1:.text는 400페이지부터 200페이지 분량이다.                       |
| - 항목 2:.data는 600페이지부터 50페이지 분량이다.                        |
| - 항목 3:.symtab은 800페이지에 있고,.strtab을 참조한다.                  |
+-------------------------------------------------------------------------+
```

핵심은 ELF 헤더가 **섹션 헤더 테이블(목차)**의 위치를 알려주고, 그 목차가 실제 **본문(Section Body)**의 위치를 알려준다는 것입니다.

2. 섹션 헤더와 본문의 관계: "잘라내기" (Slicing)

사용자께서 가장 헷갈려 하시는 부분이 "헤더는 읽었는데 본문을 어떻게 뽑냐"는 것입니다. 섹션 헤더는 파일 내의 특정 영역을 가리키는 좌표일 뿐입니다.

시각적 예시:
.rodata 섹션 추출하기

Elf64_Shdr 구조체의 핵심 필드는 sh_offset과 sh_size입니다.

```text
[ ELF 파일 전체 (0x0000 ~ End) ]

0x0000  +------------------------+
        | ELF Header             |
        +------------------------+
        | ...                    |

0x2000  +------------------------+  <--- [ sh_offset: 0x2000 ] (시작점)
        | (실제 데이터)            |  <--- 이 구간을 읽으면 "본문"입니다.
        | ...                    |
        +------------------------+  <--- [ sh_offset + sh_size ] (끝점)

        +------------------------+
        | ...                    |
        +------------------------+
        | Section Header Table   |
        +------------------------+
```

추출 알고리즘:

섹션 헤더에서 sh_offset (예: 0x2000)을 읽습니다.
섹션 헤더에서 sh_size (예: 0x0100)를 읽습니다.
파일 포인터를 0x2000으로 이동합니다 (fseek).
그 위치에서 0x0100 바이트만큼 읽습니다 (fread).
이것이 바로 섹션 본문입니다.

3. 심볼 테이블(Symbol Table)의 구조와 연결

심볼 테이블(SHT_SYMTAB)도 하나의 섹션입니다. 따라서 위와 똑같은 방식으로 본문을 읽어옵니다. 다만, **심볼 테이블의 본문은 단순한 바이트 덩어리가 아니라 Elf64_Sym 구조체의 배열(Array)**이라는 점이 다릅니다.

여기서 가장 어려운 개념인 **"3각 관계"**가 등장합니다.

Symbol Table: 주소록 (이름 인덱스 + 주소)
String Table: 실제 이름 문자열들의 저장소
Data/Code Section: 실제 변수값이나 함수 코드가 있는 곳

3.1 3각 관계 시각화 (The Triangle)

(1) Symbol Table Entry (Elf64_Sym)

```text
+-----------------------------------+
| st_name  : 0x1A (이름의 위치)       |
| st_value : 0x403010 (값의 주소)     |
| st_shndx : 3 (.data 섹션 인덱스)    |
+-----------------------------------+
          | (2) 이름 찾으러 가기                    | (3) 실제 값 찾으러 가기
          v                                       v
+--------------------------+            +--------------------------+
| Section Header [.strtab] |            | Section Header 3         |
| Type: SHT_STRTAB         |            | Name:.data               |
| sh_offset: 0x3000        |            | sh_addr: 0x403000        |
| ...                      |            | sh_offset: 0x3000        |
+--------------------------+            | ...                      |
          | (본문 참조)                 +--------------------------+
          v                                        |
+--------------------------+                       | v (파일 오프셋 계산)
| .strtab Section Body     |                       |
| (문자열 뭉치)            |                         v
| Offset 0x1A: "my_var\0"  |            +--------------------------+
| ...                      |            | .data Section Body       |
+--------------------------+            | (Offset 0x3000)          |
          |                             | ...                      |
          +-----> "찾았다! 변수 이름"     | Offset 0x3010: [값]       |
                                        | ...                      |
                                        +--------------------------+
                                                  |
                                                  +-----> "찾았다! 변수 값"
```

4. 단계별 상세 분석 (Step-by-Step Walkthrough)

사용자께서 제공해주신 로그 데이터를 기반으로, **st_name (이름)**과 **st_value (값)**을 찾아가는 과정을 아주 구체적으로 시각화하겠습니다.

상황 설정
분석할 심볼: g_auth_key (전역 변수)
심볼 테이블 섹션 헤더 (sh_link: 5 -> 문자열 테이블이 5번 섹션에 있다는 뜻)

STEP 1: 이름 찾기 (st_name의 비밀)

심볼 테이블(Elf64_Sym)에는 "g_auth_key"라는 문자열이 직접 들어있지 않습니다. 대신 **숫자(오프셋)**만 들어있습니다.

[구조체 데이터]

```text
CElf64_Sym symbol_entry;
symbol_entry.st_name = 0x10; // 16번지
```

[과정 시각화]

섹션 헤더에서 sh_link 값을 봅니다. (값: 5)
**5번 섹션(.strtab)**의 본문을 메모리로 가져옵니다.
가져온 5번 섹션 본문 데이터 배열에서 0x10번째 인덱스를 봅니다.

```text
index | 00 01 02 03 04 05 06 07 08 09 0A 0B 0C 0D 0E 0F
0000 | 00 6D 61 69 6E 00 74 65 73 74 00 66 75 6E 63 00 (.main.test.func.)
0010 | 67 5F 61 75 74 68 5F 6B 65 79 00...            ( g_auth_key. )
^|
+--- 여기가 0x10 (16) 번째 바이트입니다.
```

여기서부터 NULL(00)이 나올 때까지 읽으면 "g_auth_key"가 됩니다.

STEP 2: 실제 데이터 위치 찾기 (st_value의 변환)

여기가 가장 헷갈리는 부분입니다. st_value는 파일 오프셋이 아니라 **가상 메모리 주소(Virtual Address)**인 경우가 많습니다. 파일에서 데이터를 읽으려면 이 주소를 파일 오프셋으로 변환해야 합니다.

[구조체 데이터]

```text
Csymbol_entry.st_value = 0x403010; // 메모리 상의 주소
symbol_entry.st_shndx = 3;        // 3번 섹션(.data)에 살고 있음
```

[3번 섹션 헤더 정보]

Section Header 3 (.data)
sh_addr (메모리에 로딩될 시작 주소) : 0x403000
sh_offset (파일에서의 시작 위치)    : 0x3000

[파일 오프셋 계산 공식 시각화]

우리는 파일 안에서의 위치(Target_File_Offset)를 알고 싶습니다.

```text
메모리 세상 (Virtual Memory)                    파일 세상 (File on Disk)
+---------------------------+                   +---------------------------+
| 0x403000 (.data 시작)      |   <--- 매핑 --->  | 0x3000 (.data 시작)        |
| ...                       |                   | ...                       |
| 0x403010 (심볼 위치)       |   ---- 변환 ---->  | 0x3010 (심볼의 파일 위치)   |
+---------------------------+                   +---------------------------+
```

Offset Delta (거리) 계산:
심볼이 섹션 시작점으로부터 얼마나 떨어져 있나요?
0x403010 (심볼) - 0x403000 (섹션 시작) = 0x10 (16바이트)

파일 오프셋 적용:
파일에서의 섹션 시작점에 그 거리를 더해줍니다.
0x3000 (파일 섹션 시작) + 0x10 (거리) = 0x3010

결과:
파일의 0x3010 위치로 fseek 하여 데이터를 읽으면, 그것이 바로 g_auth_key의 초기값입니다.

5. 섹션 헤더의 sh_link와 sh_info 완전 정복

이 두 필드는 섹션의 타입에 따라 의미가 변하는 카멜레온 같은 녀석들입니다. 이 표만 기억하시면 됩니다.

```text
+-------------------+----------------------------+-----------------------------+
| 섹션 타입 (Type) | sh_link의 의미 (화살표) | sh_info의 의미 (추가 정보) |
+-------------------+----------------------------+-----------------------------+
| SHT_SYMTAB | "이름은 어디에?" | "로컬 심볼은 몇 개?" |
| (심볼 테이블) | -> 문자열 테이블 섹션 인덱스| -> 마지막 로컬 심볼 인덱스+1|
+-------------------+----------------------------+-----------------------------+
| SHT_RELA | "심볼은 어디에?" | "수정할 곳은 어디에?" |
| (재배치 정보) | -> 심볼 테이블 섹션 인덱스 | -> 코드가 있는 섹션(.text) |
+-------------------+----------------------------+-----------------------------+
| SHT_DYNAMIC | "문자열은 어디에?" | (사용 안 함: 0) |
| (동적 링킹) | -> 문자열 테이블 섹션 인덱스| |
+-------------------+----------------------------+-----------------------------+
```

시각적 연결도 (Relocation의 경우)
재배치(Relocation) 섹션은 가장 복잡한 연결을 가집니다.

```text
[.rela.text 섹션 헤더 ]
|
|+--- sh_link (참조할 심볼 목록) ----> [.symtab 섹션 ]
|
|+--- sh_info (수정할 코드 영역) ----> [.text 섹션 ]
```

즉, "나는 .text 섹션을 수정할 건데, 거기에 들어갈 주소 정보는 .symtab에서 가져올 거야"라는 뜻입니다.

6. 요약 및 행동 지침

이제 정리하자면, ELF 파일에서 심볼의 이름과 본문 내용을 뽑아내는 과정은 다음과 같습니다.

헤더 읽기: ELF Header를 읽어 Section Header Table 위치 파악.
문자열 테이블 찾기: e_shstrndx가 가리키는 섹션을 찾아 그 본문을 메모리에 로드 (이게 없으면 섹션 이름조차 모름).
심볼 테이블 찾기: 섹션 헤더를 돌면서 Type이 SHT_SYMTAB인 것을 찾음.
심볼 이름 해석용 테이블 로드: 찾은 심볼 테이블 헤더의 sh_link가 가리키는 섹션(문자열 테이블)의 본문을 로드.
심볼 파싱: 심볼 테이블 본문(Elf64_Sym 배열)을 하나씩 읽음.
st_name: 아까 로드한 문자열 테이블에서 이름 찾기.
st_shndx: 이 심볼이 속한 섹션 인덱스 확인.
st_value: 해당 섹션의 sh_addr와 sh_offset을 이용해 파일 오프셋 계산.
데이터 추출: 계산된 파일 오프셋에서 st_size만큼 읽어내기.

이 그림과 흐름을 머릿속에 담고 코드를 다시 보시면, sh_link가 왜 필요하고 st_name이 왜 숫자인지 명확히 보이실 것입니다.